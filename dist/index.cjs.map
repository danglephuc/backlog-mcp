{"version":3,"sources":["../src/server.ts","../src/services/BacklogClient.ts","../src/services/TaskFileManager.ts","../src/utils/config.ts","../src/index.ts"],"sourcesContent":["import { McpServer, ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { z } from 'zod';\nimport { BacklogClient } from './services/BacklogClient.js';\nimport { TaskFileManager } from './services/TaskFileManager.js';\nimport { BacklogConfig } from './types/backlog.js';\nimport { Config } from './utils/config.js';\n\nexport class BacklogMcpServer {\n  private server: McpServer;\n  private backlogClient: BacklogClient | null = null;\n  private taskManager: TaskFileManager;\n  private config: Config | undefined;\n\n  constructor(config?: Config) {\n    this.server = new McpServer({\n      name: 'backlog-mcp',\n      version: '1.0.0'\n    });\n    this.config = config;\n    this.taskManager = new TaskFileManager(config?.tasksDir || '.tasks');\n    this.setupTools();\n    this.setupResources();\n  }\n\n  private setupTools(): void {\n    // Sync issues tool\n    this.server.registerTool(\n      'sync-issues',\n      {\n        title: 'Sync Backlog Issues',\n        description: 'Sync issues from Backlog to local .tasks folder',\n        inputSchema: {}\n      },\n      async () => {\n        try {\n          // Use config from constructor instead of input\n          if (!this.config) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Server configuration not found. Please ensure apiKey, baseUrl, and projectKey are provided.'\n              }],\n              isError: true\n            };\n          }\n\n          // Initialize Backlog client\n          const config: BacklogConfig = { \n            apiKey: this.config.apiKey, \n            baseUrl: this.config.baseUrl, \n            projectKey: this.config.projectKey \n          };\n          this.backlogClient = new BacklogClient(config);\n\n          // Test connection\n          const isConnected = await this.backlogClient.testConnection();\n          if (!isConnected) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Failed to connect to Backlog. Please check your API key and base URL.'\n              }]\n            };\n          }\n\n          // Initialize task manager\n          await this.taskManager.initialize();\n\n          // Get last sync time from file\n          const lastSyncTime = await this.taskManager.getLastSyncTime();\n          const currentSyncTime = new Date().toISOString();\n\n          // Get issues\n          let issues;\n          let syncMessage = '';\n          if (lastSyncTime) {\n            const sinceDate = new Date(lastSyncTime);\n            issues = await this.backlogClient.getIssuesUpdatedSince(sinceDate);\n            syncMessage = `Synced ${issues.length} issues updated since ${new Date(lastSyncTime).toLocaleString()}`;\n          } else {\n            issues = await this.backlogClient.getIssues();\n            syncMessage = `Synced ${issues.length} issues (full sync - first time)`;\n          }\n\n          // Sync issues to task files\n          await this.taskManager.syncIssues(issues, this.config.baseUrl, this.config.ignoreIssueTypes);\n\n          // Cleanup removed issues if doing a full sync (first time)\n          if (!lastSyncTime) {\n            const currentIssueKeys = issues.map(issue => issue.issueKey);\n            await this.taskManager.cleanupRemovedIssues(currentIssueKeys);\n          }\n\n          // Save current sync time for next time\n          await this.taskManager.saveLastSyncTime(currentSyncTime, issues);\n\n          // Create success message with filtering info\n          let message = `âœ… ${syncMessage}`;\n          if (this.config.ignoreIssueTypes && this.config.ignoreIssueTypes.length > 0) {\n            message += `\\nIgnored issue types: ${this.config.ignoreIssueTypes.join(', ')}`;\n          }\n          message += `\\nSaved to: ${this.taskManager.getTasksDirectory()}`;\n          message += `\\nNext sync will check for updates since: ${new Date(currentSyncTime).toLocaleString()}`;\n\n          return {\n            content: [{\n              type: 'text',\n              text: message\n            }]\n          };\n        } catch (error) {\n          return {\n            content: [{\n              type: 'text',\n              text: `Error syncing issues: ${error}`\n            }],\n            isError: true\n          };\n        }\n      }\n    );\n\n    // Get single issue tool\n    this.server.registerTool(\n      'get-issue',\n      {\n        title: 'Get Backlog Issue',\n        description: 'Get details of a specific Backlog issue',\n        inputSchema: {\n          issueKey: z.string().describe('Issue key (e.g., PROJ-123)')\n        }\n      },\n      async ({ issueKey }) => {\n        try {\n          if (!this.config) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Server configuration not found. Please ensure apiKey, baseUrl, and projectKey are provided.'\n              }],\n              isError: true\n            };\n          }\n\n          const config: BacklogConfig = { \n            apiKey: this.config.apiKey, \n            baseUrl: this.config.baseUrl, \n            projectKey: this.config.projectKey \n          };\n          const client = new BacklogClient(config);\n\n          const issue = await client.getIssue(issueKey);\n          \n          return {\n            content: [{\n              type: 'text',\n              text: JSON.stringify(issue, null, 2)\n            }]\n          };\n        } catch (error) {\n          return {\n            content: [{\n              type: 'text',\n              text: `Error getting issue: ${error}`\n            }],\n            isError: true\n          };\n        }\n      }\n    );\n\n    // Test connection tool\n    this.server.registerTool(\n      'test-connection',\n      {\n        title: 'Test Backlog Connection',\n        description: 'Test connection to Backlog API',\n        inputSchema: {}\n      },\n      async () => {\n        try {\n          if (!this.config) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Server configuration not found. Please ensure apiKey, baseUrl, and projectKey are provided.'\n              }],\n              isError: true\n            };\n          }\n\n          const config: BacklogConfig = { \n            apiKey: this.config.apiKey, \n            baseUrl: this.config.baseUrl, \n            projectKey: this.config.projectKey \n          };\n          const client = new BacklogClient(config);\n\n          const isConnected = await client.testConnection();\n          if (isConnected) {\n            const project = await client.getProject();\n            return {\n              content: [{\n                type: 'text',\n                text: `âœ… Successfully connected to Backlog!\\nProject: ${project.name} (${project.projectKey})`\n              }]\n            };\n          } else {\n            return {\n              content: [{\n                type: 'text',\n                text: 'âŒ Failed to connect to Backlog. Please check your credentials.'\n              }],\n              isError: true\n            };\n          }\n        } catch (error) {\n          return {\n            content: [{\n              type: 'text',\n              text: `âŒ Connection test failed: ${error}`\n            }],\n            isError: true\n          };\n        }\n      }\n    );\n\n    // Update issues tool\n    this.server.registerTool(\n      'update-issues',\n      {\n        title: 'Update Backlog Issues',\n        description: 'Update Backlog issues with changes from local task files',\n        inputSchema: {\n          issueKeys: z.array(z.string()).describe('Array of issue keys (e.g., [\"PROJ-123\", \"PROJ-124\"])')\n        }\n      },\n      async ({ issueKeys }) => {\n        try {\n          if (!this.config) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Server configuration not found. Please ensure apiKey, baseUrl, and projectKey are provided.'\n              }],\n              isError: true\n            };\n          }\n\n          if (!issueKeys || issueKeys.length === 0) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'âŒ No issue keys provided. Please specify at least one issue key.'\n              }],\n              isError: true\n            };\n          }\n\n          // Initialize Backlog client\n          const config: BacklogConfig = { \n            apiKey: this.config.apiKey, \n            baseUrl: this.config.baseUrl, \n            projectKey: this.config.projectKey \n          };\n          const client = new BacklogClient(config);\n\n          const results: string[] = [];\n          let successCount = 0;\n          let errorCount = 0;\n\n          for (const issueKey of issueKeys) {\n            try {\n              // Read the local task file\n              const taskData = await this.taskManager.readTaskFile(issueKey);\n              if (!taskData) {\n                results.push(`âŒ ${issueKey}: Local task file not found`);\n                errorCount++;\n                continue;\n              }\n\n              // Get the original issue to compare\n              let originalIssue;\n              try {\n                originalIssue = await client.getIssue(issueKey);\n              } catch (error) {\n                results.push(`âŒ ${issueKey}: Failed to fetch from Backlog`);\n                errorCount++;\n                continue;\n              }\n\n              // Check what has changed\n              const changes: { summary?: string; description?: string } = {};\n              let changesList: string[] = [];\n\n              if (taskData.title && taskData.title !== originalIssue.summary) {\n                changes.summary = taskData.title;\n                changesList.push(`Title updated`);\n              }\n\n              // Compare descriptions, treating null/undefined as empty string\n              const localDesc = taskData.description || '';\n              const backlogDesc = originalIssue.description || '';\n              \n              if (localDesc !== backlogDesc) {\n                // Safety check: if local is empty but Backlog has content, be careful\n                if (!localDesc && backlogDesc) {\n                  changesList.push(`Description update skipped (would remove existing content)`);\n                } else {\n                  changes.description = localDesc;\n                  if (localDesc && backlogDesc) {\n                    changesList.push(`Description updated`);\n                  } else if (localDesc && !backlogDesc) {\n                    changesList.push(`Description added`);\n                  }\n                }\n              }\n\n              // If no changes, skip update\n              if (Object.keys(changes).length === 0) {\n                results.push(`â­ï¸  ${issueKey}: No changes detected`);\n                continue;\n              }\n\n              // Update the issue\n              await client.updateIssue(issueKey, changes);\n              results.push(`âœ… ${issueKey}: ${changesList.join(', ')}`);\n              successCount++;\n\n            } catch (error) {\n              results.push(`âŒ ${issueKey}: Update failed - ${error}`);\n              errorCount++;\n            }\n          }\n\n          const summary = `ðŸ“Š Summary: ${successCount} updated, ${errorCount} errors, ${issueKeys.length - successCount - errorCount} skipped`;\n          \n          return {\n            content: [{\n              type: 'text',\n              text: `${summary}\\n\\n${results.join('\\n')}`\n            }]\n          };\n        } catch (error) {\n          return {\n            content: [{\n              type: 'text',\n              text: `âŒ Failed to update issues: ${error}`\n            }],\n            isError: true\n          };\n        }\n      }\n    );\n\n    // List task files tool\n    this.server.registerTool(\n      'list-task-files',\n      {\n        title: 'List Task Files',\n        description: 'List existing task files in .tasks directory',\n        inputSchema: {}\n      },\n      async () => {\n        try {\n          const taskFiles = await this.taskManager.getExistingTaskFiles();\n          const tasksDir = this.taskManager.getTasksDirectory();\n          \n          if (taskFiles.length === 0) {\n            return {\n              content: [{\n                type: 'text',\n                text: `No task files found in ${tasksDir}`\n              }]\n            };\n          }\n\n          return {\n            content: [{\n              type: 'text',\n              text: `Found ${taskFiles.length} task files in ${tasksDir}:\\n${taskFiles.map(file => `- ${file}`).join('\\n')}`\n            }]\n          };\n        } catch (error) {\n          return {\n            content: [{\n              type: 'text',\n              text: `Error listing task files: ${error}`\n            }],\n            isError: true\n          };\n        }\n      }\n    );\n\n    // Bulk create tasks tool\n    this.server.registerTool(\n      'bulk-create-tasks',\n      {\n        title: 'Bulk Create Tasks',\n        description: 'Create Backlog issues from local temporary task files in parent folders',\n        inputSchema: {}\n      },\n      async () => {\n        try {\n          if (!this.config) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Server configuration not found. Please ensure apiKey, baseUrl, and projectKey are provided.'\n              }],\n              isError: true\n            };\n          }\n\n          // Initialize Backlog client\n          const config: BacklogConfig = { \n            apiKey: this.config.apiKey, \n            baseUrl: this.config.baseUrl, \n            projectKey: this.config.projectKey \n          };\n          this.backlogClient = new BacklogClient(config);\n\n          // Test connection\n          const isConnected = await this.backlogClient.testConnection();\n          if (!isConnected) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'Failed to connect to Backlog. Please check your API key and base URL.'\n              }],\n              isError: true\n            };\n          }\n\n          // Initialize task manager\n          await this.taskManager.initialize();\n\n          // Find all parent task folders\n          const parentFolders = await this.taskManager.findParentTaskFolders();\n          if (parentFolders.length === 0) {\n            return {\n              content: [{\n                type: 'text',\n                text: 'No parent task folders found. Parent folders should follow the pattern PARENT-{number} (e.g., SBK-2).'\n              }]\n            };\n          }\n\n          const results: string[] = [];\n          let totalCreated = 0;\n          let totalErrors = 0;\n\n          // Process each parent folder\n          for (const parentFolder of parentFolders) {\n            results.push(`\\nðŸ“ Processing parent folder: ${parentFolder}`);\n            \n            // Find temporary task files in this parent folder\n            const tempFiles = await this.taskManager.findTemporaryTaskFiles(parentFolder);\n            \n            if (tempFiles.length === 0) {\n              results.push(`  â­ï¸  No temporary task files found in ${parentFolder}`);\n              continue;\n            }\n\n            results.push(`  ðŸ“„ Found ${tempFiles.length} temporary task files`);\n\n            // Get parent issue ID if parent folder exists in Backlog\n            let parentIssueId: number | undefined;\n            try {\n              const parentIssue = await this.backlogClient!.getIssue(parentFolder);\n              parentIssueId = parentIssue.id;\n              results.push(`  ðŸ”— Found parent issue: ${parentIssue.summary} (ID: ${parentIssueId})`);\n            } catch (error) {\n              results.push(`  âš ï¸  Parent issue ${parentFolder} not found in Backlog, creating as standalone issues`);\n            }\n\n            // Create issues for each temporary file\n            for (const tempFile of tempFiles) {\n              try {\n                const { fileName, filePath, content } = tempFile;\n                \n                // Create issue in Backlog\n                const issueData = {\n                  summary: content.title || `Task from ${fileName}`,\n                  description: content.description || '',\n                  parentIssueId: parentIssueId\n                };\n\n                const createdIssue = await this.backlogClient!.createIssue(issueData);\n                \n                // Rename local file to use real issue key\n                await this.taskManager.renameTaskFile(filePath, createdIssue.issueKey);\n                \n                // Create proper task file with correct content\n                await this.taskManager.createTaskFile(\n                  createdIssue.issueKey,\n                  parentFolder,\n                  content.title || createdIssue.summary,\n                  content.description || createdIssue.description || '',\n                  this.config.baseUrl\n                );\n\n                results.push(`  âœ… Created ${createdIssue.issueKey}: ${createdIssue.summary}`);\n                totalCreated++;\n                \n              } catch (error) {\n                results.push(`  âŒ Failed to create issue for ${tempFile.fileName}: ${error}`);\n                totalErrors++;\n              }\n            }\n          }\n\n          const summary = `\\nðŸ“Š Summary: ${totalCreated} issues created, ${totalErrors} errors`;\n          \n          return {\n            content: [{\n              type: 'text',\n              text: `ðŸš€ Bulk Create Tasks Complete${summary}\\n\\n${results.join('\\n')}`\n            }]\n          };\n\n        } catch (error) {\n          return {\n            content: [{\n              type: 'text',\n              text: `âŒ Failed to bulk create tasks: ${error}`\n            }],\n            isError: true\n          };\n        }\n      }\n    );\n  }\n\n  private setupResources(): void {\n    // Resource for task files\n    this.server.registerResource(\n      'task-file',\n      new ResourceTemplate('task://{issueKey}', { list: undefined }),\n      {\n        title: 'Task File',\n        description: 'Access task files by issue key',\n        mimeType: 'text/markdown'\n      },\n      async (uri, { issueKey }) => {\n        try {\n          // Ensure issueKey is a string (could be string[] from URI parameters)\n          const key = Array.isArray(issueKey) ? issueKey[0] : issueKey;\n          const filePath = `${this.taskManager.getTasksDirectory()}/${key}.md`;\n          const exists = await this.taskManager.taskFileExists(key);\n          \n          if (!exists) {\n            throw new Error(`Task file for ${key} not found`);\n          }\n\n          // In a real implementation, you'd read the file content here\n          // For now, we'll return a placeholder\n          return {\n            contents: [{\n              uri: uri.href,\n              text: `Task file for ${issueKey} located at ${filePath}`,\n              mimeType: 'text/markdown'\n            }]\n          };\n        } catch (error) {\n          throw new Error(`Failed to read task file: ${error}`);\n        }\n      }\n    );\n\n    // Resource for tasks directory listing\n    this.server.registerResource(\n      'tasks-directory',\n      'tasks://directory',\n      {\n        title: 'Tasks Directory',\n        description: 'List all task files in the .tasks directory',\n        mimeType: 'text/plain'\n      },\n      async (uri) => {\n        try {\n          const taskFiles = await this.taskManager.getExistingTaskFiles();\n          const tasksDir = this.taskManager.getTasksDirectory();\n          \n          const content = taskFiles.length > 0 \n            ? `Tasks directory: ${tasksDir}\\n\\nTask files:\\n${taskFiles.map(file => `- ${file}`).join('\\n')}`\n            : `Tasks directory: ${tasksDir}\\n\\nNo task files found.`;\n\n          return {\n            contents: [{\n              uri: uri.href,\n              text: content,\n              mimeType: 'text/plain'\n            }]\n          };\n        } catch (error) {\n          throw new Error(`Failed to list tasks directory: ${error}`);\n        }\n      }\n    );\n  }\n\n  async start(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n  }\n} ","import axios, { AxiosInstance, AxiosResponse } from 'axios';\nimport { \n  BacklogConfig, \n  BacklogIssue, \n  BacklogProject, \n  BacklogIssueListParams,\n  BacklogApiResponse \n} from '../types/backlog.js';\n\nexport class BacklogClient {\n  private axiosInstance: AxiosInstance;\n  private config: BacklogConfig;\n\n  constructor(config: BacklogConfig) {\n    this.config = config;\n    \n    // Create axios instance with base configuration\n    this.axiosInstance = axios.create({\n      baseURL: `${config.baseUrl}/api/v2`,\n      timeout: 30000,\n      params: {\n        apiKey: config.apiKey\n      }\n    });\n\n    // Add request interceptor for logging\n    this.axiosInstance.interceptors.request.use(\n      (config) => {\n        // Request logging removed for MCP compatibility\n        return config;\n      },\n      (error) => {\n        console.error('Request error:', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // Add response interceptor for error handling\n    this.axiosInstance.interceptors.response.use(\n      (response) => response,\n      (error) => {\n        console.error('Response error:', error.response?.data || error.message);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  /**\n   * Get project information by project key\n   */\n  async getProject(): Promise<BacklogProject> {\n    try {\n      const response: AxiosResponse<BacklogProject> = await this.axiosInstance.get(\n        `/projects/${this.config.projectKey}`\n      );\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get project: ${error}`);\n    }\n  }\n\n  /**\n   * Get issue types for the project\n   */\n  async getIssueTypes(): Promise<any[]> {\n    try {\n      const project = await this.getProject();\n      const response: AxiosResponse<any[]> = await this.axiosInstance.get(\n        `/projects/${project.id}/issueTypes`\n      );\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get issue types: ${error}`);\n    }\n  }\n\n  /**\n   * Get priorities (global, not project-specific)\n   */\n  async getPriorities(): Promise<any[]> {\n    try {\n      const response: AxiosResponse<any[]> = await this.axiosInstance.get(\n        `/priorities`\n      );\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get priorities: ${error}`);\n    }\n  }\n\n\n  /**\n   * Get list of issues for the project\n   */\n  async getIssues(params: BacklogIssueListParams = {}): Promise<BacklogIssue[]> {\n    try {\n      // Get project info to get project ID\n      const project = await this.getProject();\n      \n      const allIssues: BacklogIssue[] = [];\n      let offset = 0;\n      const limit = 100; // Backlog API max per request\n      \n      while (true) {\n        // Set parameters for this page\n        const queryParams = {\n          projectId: [project.id],\n          sort: 'updated',\n          order: 'desc' as const,\n          count: limit,\n          offset: offset,\n          ...params\n        };\n\n        const response: AxiosResponse<BacklogIssue[]> = await this.axiosInstance.get(\n          '/issues',\n          { params: queryParams }\n        );\n        \n        const issues = response.data;\n        allIssues.push(...issues);\n        \n        // If we got fewer issues than the limit, we've reached the end\n        if (issues.length < limit) {\n          break;\n        }\n        \n        offset += limit;\n      }\n      \n      return allIssues;\n    } catch (error) {\n      throw new Error(`Failed to get issues: ${error}`);\n    }\n  }\n\n  /**\n   * Get a specific issue by issue key\n   */\n  async getIssue(issueKey: string): Promise<BacklogIssue> {\n    try {\n      const response: AxiosResponse<BacklogIssue> = await this.axiosInstance.get(\n        `/issues/${issueKey}`\n      );\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get issue ${issueKey}: ${error}`);\n    }\n  }\n\n  /**\n   * Create a new issue\n   */\n  async createIssue(issueData: { \n    summary: string; \n    description?: string; \n    issueTypeId?: number; \n    priorityId?: number; \n    parentIssueId?: number;\n  }): Promise<BacklogIssue> {\n    try {\n      const createData: any = {\n        projectId: (await this.getProject()).id,\n        summary: issueData.summary,\n        description: issueData.description || ''\n      };\n      \n      // Set issueTypeId - use provided value or find default \"Task\" type\n      if (issueData.issueTypeId) {\n        createData.issueTypeId = issueData.issueTypeId;\n      } else {\n        const issueTypes = await this.getIssueTypes();\n        const taskType = issueTypes.find(type => type.name === 'Task');\n        if (taskType) {\n          createData.issueTypeId = taskType.id;\n        } else {\n          // If no \"Task\" type found, use the first available type\n          createData.issueTypeId = issueTypes[0]?.id;\n        }\n      }\n      \n      // Set priorityId - use provided value or find default priority\n      if (issueData.priorityId) {\n        createData.priorityId = issueData.priorityId;\n      } else {\n        const priorities = await this.getPriorities();\n        // Look for \"Normal\" priority first, then use the first available\n        const normalPriority = priorities.find(priority => priority.name === 'Normal');\n        if (normalPriority) {\n          createData.priorityId = normalPriority.id;\n        } else {\n          // If no \"Normal\" priority found, use the first available\n          createData.priorityId = priorities[0]?.id;\n        }\n      }\n      \n      if (issueData.parentIssueId) {\n        createData.parentIssueId = issueData.parentIssueId;\n      }\n\n      const response: AxiosResponse<BacklogIssue> = await this.axiosInstance.post(\n        '/issues',\n        createData\n      );\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to create issue: ${error}`);\n    }\n  }\n\n  /**\n   * Update an existing issue\n   */\n  async updateIssue(issueKey: string, updates: { summary?: string; description?: string }): Promise<BacklogIssue> {\n    try {\n      const updateData: any = {};\n      \n      // Ensure we have at least one field to update\n      if (!updates.summary && !updates.description) {\n        throw new Error('No updates provided');\n      }\n      \n      if (updates.summary) {\n        updateData.summary = updates.summary;\n      }\n      \n      if (updates.description !== undefined) {\n        // Backlog API sometimes requires description to be non-empty\n        updateData.description = updates.description || '';\n      }\n\n      const response: AxiosResponse<BacklogIssue> = await this.axiosInstance.patch(\n        `/issues/${issueKey}`,\n        updateData\n      );\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to update issue ${issueKey}: ${error}`);\n    }\n  }\n\n  /**\n   * Get issues updated since a specific date\n   */\n  async getIssuesUpdatedSince(since: Date): Promise<BacklogIssue[]> {\n    // Format date as yyyy-MM-dd as required by Backlog API\n    const formattedDate = since.toISOString().split('T')[0];\n    return this.getIssues({\n      updatedSince: formattedDate,\n      sort: 'updated',\n      order: 'desc'\n    });\n  }\n\n  /**\n   * Test the connection and authentication\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      await this.getProject();\n      return true;\n    } catch (error) {\n      console.error('Connection test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get the base URL for creating issue links\n   */\n  getIssueUrl(issueKey: string): string {\n    return `${this.config.baseUrl}/view/${issueKey}`;\n  }\n\n  /**\n   * Get project key\n   */\n  getProjectKey(): string {\n    return this.config.projectKey;\n  }\n} ","import { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { BacklogIssue } from '../types/backlog.js';\n\n// Helper to ensure a directory exists (like fs-extra's ensureDir)\nasync function ensureDir(dir: string) {\n  await fs.mkdir(dir, { recursive: true });\n}\n\nexport interface TaskFile {\n  issueKey: string;\n  title: string;\n  description: string;\n  status: string;\n  priority: string;\n  assignee?: string;\n  created: string;\n  updated?: string;\n  dueDate?: string;\n  url: string;\n  tags: string[];\n  filePath: string;\n}\n\nexport class TaskFileManager {\n  private tasksDir: string;\n\n  constructor(tasksDir: string = '.tasks') {\n    // For relative paths, resolve relative to current working directory (project root)\n    // For absolute paths, use as-is\n    if (path.isAbsolute(tasksDir)) {\n      this.tasksDir = tasksDir;\n    } else {\n      // Use process.cwd() to ensure it's relative to the client's working directory\n      this.tasksDir = path.resolve(process.cwd(), tasksDir);\n    }\n  }\n\n  /**\n   * Initialize the tasks directory and others subfolder\n   */\n  async initialize(): Promise<void> {\n    try {\n      await ensureDir(this.tasksDir);\n      await ensureDir(path.join(this.tasksDir, 'others'));\n    } catch (error) {\n      throw new Error(`Failed to initialize tasks directory: ${error}`);\n    }\n  }\n\n  /**\n   * Find existing task file across all subfolders (including nested directories)\n   */\n  async findExistingTaskFile(issueKey: string): Promise<string | null> {\n    try {\n      return await this.searchTaskFileRecursively(this.tasksDir, issueKey);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Recursively search for a task file in a directory and its subdirectories\n   */\n  private async searchTaskFileRecursively(dir: string, issueKey: string): Promise<string | null> {\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        \n        if (entry.isDirectory()) {\n          // Recursively search in subdirectories\n          const found = await this.searchTaskFileRecursively(fullPath, issueKey);\n          if (found) return found;\n        } else if (entry.isFile() && entry.name === `${issueKey}.md`) {\n          // Found the task file\n          return fullPath;\n        }\n      }\n      \n      return null; // Not found in this directory or its subdirectories\n    } catch (error) {\n      // Skip directories that can't be read\n      return null;\n    }\n  }\n\n  /**\n   * Move a task file from one location to another\n   */\n  private async moveTaskFile(issueKey: string, fromPath: string, toPath: string): Promise<void> {\n    try {\n      // Ensure target directory exists\n      await ensureDir(path.dirname(toPath));\n      \n      // Copy the file content\n      const content = await fs.readFile(fromPath, 'utf8');\n      await fs.writeFile(toPath, content, 'utf8');\n      \n      // Remove old file\n      await fs.rm(fromPath);\n      \n      console.error(`Moved ${issueKey}: ${fromPath} â†’ ${toPath}`);\n    } catch (error) {\n      console.error(`Failed to move ${issueKey} from ${fromPath} to ${toPath}:`, error);\n    }\n  }\n\n  /**\n   * Filter issues to exclude ignored issue types\n   */\n  private filterIgnoredIssueTypes(issues: BacklogIssue[], ignoreIssueTypes?: string[]): BacklogIssue[] {\n    if (!ignoreIssueTypes || ignoreIssueTypes.length === 0) {\n      return issues;\n    }\n    \n    return issues.filter(issue => !ignoreIssueTypes.includes(issue.issueType.name));\n  }\n\n  /**\n   * Check if a folder name is a custom renamed parent folder (has suffix after issue key)\n   */\n  private isCustomParentFolder(folderName: string): boolean {\n    // Match pattern: PROJ-123-something or PROJ-123.something or PROJ-123_something\n    const customParentPattern = /^[A-Z]+-\\d+[-._].+/;\n    return customParentPattern.test(folderName);\n  }\n\n  /**\n   * Convert a Backlog issue to a task file\n   */\n  async issueToTaskFile(issue: BacklogIssue, baseUrl: string, allIssues: BacklogIssue[] = []): Promise<TaskFile> {\n    const tags = [\n      issue.issueType.name,\n      issue.priority.name,\n      issue.status.name,\n      ...issue.category.map(cat => cat.name),\n      ...issue.versions.map(ver => ver.name),\n      ...issue.milestone.map(mil => mil.name)\n    ].filter(tag => tag && tag.trim() !== '');\n\n    return {\n      issueKey: issue.issueKey,\n      title: issue.summary,\n      description: issue.description || '',\n      status: issue.status.name,\n      priority: issue.priority.name,\n      assignee: issue.assignee?.name,\n      created: issue.created,\n      updated: issue.updated,\n      dueDate: issue.dueDate,\n      url: `${baseUrl}/view/${issue.issueKey}`,\n      tags,\n      filePath: '' // Will be set by caller\n    };\n  }\n\n  /**\n   * Generate markdown content for a task file\n   */\n  private generateMarkdownContent(task: TaskFile): string {\n    let content = `# ${task.title}\\n\\n`;\n    \n    // Add description directly (everything after title)\n    if (task.description && task.description.trim() !== '') {\n      content += task.description;\n    }\n    \n    return content;\n  }\n\n  /**\n   * Sync a single issue to a task file\n   */\n  async syncIssue(issue: BacklogIssue, baseUrl: string, allIssues: BacklogIssue[] = []): Promise<void> {\n    try {\n      // Find existing file location\n      const existingPath = await this.findExistingTaskFile(issue.issueKey);\n      if (!existingPath) return; // File doesn't exist, will be handled by recovery\n\n      const task = await this.issueToTaskFile(issue, baseUrl, allIssues);\n      task.filePath = existingPath; // Use existing location\n      const markdownContent = this.generateMarkdownContent(task);\n      \n      await fs.writeFile(existingPath, markdownContent, 'utf8');\n    } catch (error) {\n      throw new Error(`Failed to sync issue ${issue.issueKey}: ${error}`);\n    }\n  }\n\n  /**\n   * Match existing custom folders with their corresponding issues using tree structure\n   */\n  private async matchCustomFoldersWithIssues(issueTreeMap: Map<string, { issue: BacklogIssue, parent?: BacklogIssue, children: BacklogIssue[] }>): Promise<Map<string, string>> {\n    const issueToFolderMap = new Map<string, string>();\n    \n    try {\n      // First, scan for existing files and their folders\n      const existingFiles = await this.getExistingTaskFiles();\n      \n      for (const relativePath of existingFiles) {\n        const fullPath = path.join(this.tasksDir, relativePath);\n        const fileName = path.basename(fullPath, '.md');\n        const folderPath = path.dirname(fullPath);\n        \n        if (fileName.match(/^[A-Z]+-\\d+$/)) {\n          issueToFolderMap.set(fileName, folderPath);\n        }\n      }\n      \n      // Then, handle issues without existing files using tree relationships\n      for (const [issueKey, treeNode] of issueTreeMap) {\n        if (issueToFolderMap.has(issueKey)) continue; // Already has a location\n        \n        const { issue, parent, children } = treeNode;\n        \n        if (parent) {\n          // This is a child issue - try to find parent's folder\n          let parentFolder = issueToFolderMap.get(parent.issueKey);\n          \n          if (!parentFolder) {\n            // Parent folder not found by exact match, search for custom parent folders\n            const entries = await fs.readdir(this.tasksDir, { withFileTypes: true });\n            for (const entry of entries) {\n              if (entry.isDirectory() && entry.name.startsWith(`${parent.issueKey}-`)) {\n                parentFolder = path.join(this.tasksDir, entry.name);\n                issueToFolderMap.set(parent.issueKey, parentFolder); // Cache for future use\n                break;\n              }\n            }\n          }\n          \n          if (parentFolder) {\n            issueToFolderMap.set(issueKey, parentFolder);\n          } else {\n            // Parent folder not found, use others\n            issueToFolderMap.set(issueKey, path.join(this.tasksDir, 'others'));\n          }\n        } else if (children.length > 0) {\n          // This is a parent issue - check if any children have existing folders that match this parent\n          let parentFolder: string | undefined;\n          \n          // Check if there's already a custom folder for this parent\n          const entries = await fs.readdir(this.tasksDir, { withFileTypes: true });\n          for (const entry of entries) {\n            if (entry.isDirectory() && entry.name.startsWith(`${issueKey}-`)) {\n              parentFolder = path.join(this.tasksDir, entry.name);\n              break;\n            }\n          }\n          \n          if (!parentFolder) {\n            // Create default parent folder\n            parentFolder = path.join(this.tasksDir, issueKey);\n          }\n          \n          issueToFolderMap.set(issueKey, parentFolder);\n          \n          // Also assign all children to the same folder\n          for (const child of children) {\n            if (!issueToFolderMap.has(child.issueKey)) {\n              issueToFolderMap.set(child.issueKey, parentFolder);\n            }\n          }\n        } else {\n          // Standalone issue\n          issueToFolderMap.set(issueKey, path.join(this.tasksDir, 'others'));\n        }\n      }\n      \n    } catch (error) {\n      console.error('Error matching custom folders:', error);\n    }\n    \n    return issueToFolderMap;\n  }\n\n  /**\n   * Save the last sync timestamp and issue ID to key mappings to a file\n   */\n  async saveLastSyncTime(timestamp: string, issues: BacklogIssue[] = []): Promise<void> {\n    try {\n      const lastSyncFile = path.join(this.tasksDir, '.last-sync');\n      \n      // Create ID to key mapping from current issues\n      const idToKeyMap: { [id: number]: string } = {};\n      issues.forEach(issue => {\n        idToKeyMap[issue.id] = issue.issueKey;\n      });\n      \n      const syncData = {\n        timestamp,\n        idToKeyMap\n      };\n      \n      await fs.writeFile(lastSyncFile, JSON.stringify(syncData, null, 2), 'utf8');\n    } catch (error) {\n      console.error('Failed to save last sync time:', error);\n    }\n  }\n\n  /**\n   * Load the last sync timestamp and issue ID to key mappings from file\n   */\n  async getLastSyncData(): Promise<{ timestamp: string | null, idToKeyMap: { [id: number]: string } }> {\n    try {\n      const lastSyncFile = path.join(this.tasksDir, '.last-sync');\n      const content = await fs.readFile(lastSyncFile, 'utf8');\n      \n      try {\n        const syncData = JSON.parse(content);\n        \n        // Handle both old format (just timestamp) and new format (object with timestamp and mapping)\n        if (typeof syncData === 'string') {\n          // Old format - just timestamp\n          return {\n            timestamp: syncData.trim(),\n            idToKeyMap: {}\n          };\n        } else if (syncData && typeof syncData === 'object') {\n          // New format - object with timestamp and mapping\n          return {\n            timestamp: syncData.timestamp || null,\n            idToKeyMap: syncData.idToKeyMap || {}\n          };\n        }\n      } catch (parseError) {\n        // File exists but invalid JSON, treat as old format\n        return {\n          timestamp: content.trim(),\n          idToKeyMap: {}\n        };\n      }\n      \n      return { timestamp: null, idToKeyMap: {} };\n    } catch (error) {\n      // File doesn't exist or can't be read\n      return { timestamp: null, idToKeyMap: {} };\n    }\n  }\n\n  /**\n   * Get the last sync timestamp only (for backward compatibility)\n   */\n  async getLastSyncTime(): Promise<string | null> {\n    const { timestamp } = await this.getLastSyncData();\n    return timestamp;\n  }\n\n  /**\n   * Get the tasks directory path\n   */\n  getTasksDirectory(): string {\n    return this.tasksDir;\n  }\n\n  /**\n   * Build a complete issue tree map with all issues and their relationships using ID to key mapping\n   */\n  private buildIssueTreeMap(issues: BacklogIssue[], idToKeyMap: { [id: number]: string }): Map<string, { issue: BacklogIssue, parent?: BacklogIssue, children: BacklogIssue[] }> {\n    const issueMap = new Map<number, BacklogIssue>();\n    const treeMap = new Map<string, { issue: BacklogIssue, parent?: BacklogIssue, children: BacklogIssue[] }>();\n    \n    // Create lookup map with current issues\n    issues.forEach(issue => {\n      issueMap.set(issue.id, issue);\n    });\n    \n    // Build tree structure\n    issues.forEach(issue => {\n      let parent: BacklogIssue | undefined;\n      \n      if (issue.parentIssueId) {\n        // First try to find parent in current issues\n        parent = issueMap.get(issue.parentIssueId);\n        \n        // If not found in current issues, check if we have the key from previous sync\n        if (!parent && idToKeyMap[issue.parentIssueId]) {\n          const parentKey = idToKeyMap[issue.parentIssueId];\n          // Create a minimal parent object for reference\n          parent = {\n            id: issue.parentIssueId,\n            issueKey: parentKey,\n            // Add other required fields with defaults\n            projectId: issue.projectId,\n            keyId: 0,\n            issueType: issue.issueType,\n            summary: `Parent Issue ${parentKey}`,\n            description: '',\n            priority: issue.priority,\n            status: issue.status,\n            category: [],\n            versions: [],\n            milestone: [],\n            createdUser: issue.createdUser,\n            created: issue.created,\n            customFields: [],\n            attachments: [],\n            sharedFiles: [],\n            stars: []\n          } as BacklogIssue;\n        }\n      }\n      \n      const children = issues.filter(child => child.parentIssueId === issue.id);\n      \n      treeMap.set(issue.issueKey, {\n        issue,\n        parent,\n        children\n      });\n    });\n    \n    return treeMap;\n  }\n\n  /**\n   * Sync multiple issues to task files with complete tree organization using ID mapping\n   */\n  async syncIssues(issues: BacklogIssue[], baseUrl: string, ignoreIssueTypes?: string[]): Promise<void> {\n    // Filter out ignored issue types\n    const filteredIssues = this.filterIgnoredIssueTypes(issues, ignoreIssueTypes);\n    \n    if (filteredIssues.length < issues.length) {\n      const ignoredCount = issues.length - filteredIssues.length;\n      console.error(`Filtered out ${ignoredCount} issues with ignored types: ${ignoreIssueTypes?.join(', ')}`);\n    }\n    \n    // Get previous sync data for ID to key mapping\n    const { idToKeyMap } = await this.getLastSyncData();\n    \n    // Build complete issue tree map with ID mapping\n    const issueTreeMap = this.buildIssueTreeMap(filteredIssues, idToKeyMap);\n    \n    // Match existing custom folders with issues\n    const issueToFolderMap = await this.matchCustomFoldersWithIssues(issueTreeMap);\n    \n    // Recover missing files and sync all issues\n    let recoveredCount = 0;\n    for (const issue of filteredIssues) {\n      const existingPath = await this.findExistingTaskFile(issue.issueKey);\n      const targetFolder = issueToFolderMap.get(issue.issueKey) || path.join(this.tasksDir, 'others');\n      const targetPath = path.join(targetFolder, `${issue.issueKey}.md`);\n      \n      if (!existingPath) {\n        // File missing - recover it\n        await ensureDir(targetFolder);\n        const task = await this.issueToTaskFile(issue, baseUrl, filteredIssues);\n        task.filePath = targetPath; // Override with correct path\n        const markdownContent = this.generateMarkdownContent(task);\n        await fs.writeFile(targetPath, markdownContent, 'utf8');\n        recoveredCount++;\n        console.error(`Recovered missing file: ${issue.issueKey}.md in ${path.basename(targetFolder)}/`);\n      } else if (path.dirname(existingPath) !== targetFolder) {\n        // File exists but in wrong location - move it\n        await this.moveTaskFile(issue.issueKey, existingPath, targetPath);\n      } else {\n        // File exists in correct location - just update content\n        await this.syncIssue(issue, baseUrl, filteredIssues);\n      }\n    }\n    \n    if (recoveredCount > 0) {\n      console.error(`Recovered ${recoveredCount} missing task files`);\n    }\n    \n    // Create summary of organization\n    // const parentGroups = this.organizeIssuesByParent(filteredIssues);\n    // let parentFolders = 0;\n    // let childIssues = 0;\n    // let standaloneIssues = 0;\n    \n    // parentGroups.forEach((group, key) => {\n    //   if (key === 'others') {\n    //     standaloneIssues += group.children.length;\n    //   } else {\n    //     parentFolders++;\n    //     childIssues += group.children.length;\n    //     if (group.parent) childIssues++; // Count the parent issue itself\n    //   }\n    // });\n  }\n\n  /**\n   * Get list of existing task files across all subfolders (including nested directories)\n   */\n  async getExistingTaskFiles(): Promise<string[]> {\n    try {\n      const allFiles: string[] = [];\n      await this.collectTaskFilesRecursively(this.tasksDir, '', allFiles);\n      return allFiles;\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Recursively collect task files from a directory and its subdirectories\n   */\n  private async collectTaskFilesRecursively(dir: string, relativePath: string, allFiles: string[]): Promise<void> {\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        const relativeFilePath = relativePath ? `${relativePath}/${entry.name}` : entry.name;\n        \n        if (entry.isDirectory()) {\n          // Recursively search in subdirectories\n          await this.collectTaskFilesRecursively(fullPath, relativeFilePath, allFiles);\n        } else if (entry.isFile() && entry.name.endsWith('.md') && entry.name.match(/^[A-Z]+-\\d+\\.md$/)) {\n          // Add task file to the list\n          allFiles.push(relativeFilePath);\n        }\n      }\n    } catch (error) {\n      // Skip directories that can't be read\n    }\n  }\n\n  /**\n   * Check if a task file exists for an issue (search across all subfolders)\n   */\n  async taskFileExists(issueKey: string): Promise<boolean> {\n    const existingPath = await this.findExistingTaskFile(issueKey);\n    return existingPath !== null;\n  }\n\n  /**\n   * Remove a task file (search across all subfolders)\n   */\n  async removeTaskFile(issueKey: string): Promise<void> {\n    try {\n      const existingPath = await this.findExistingTaskFile(issueKey);\n      if (existingPath) {\n        await fs.rm(existingPath);\n      }\n    } catch (error) {\n      console.error(`Failed to remove task file for ${issueKey}:`, error);\n    }\n  }\n\n  /**\n   * Clean up task files for issues that no longer exist\n   */\n  async cleanupRemovedIssues(currentIssueKeys: string[]): Promise<void> {\n    try {\n      const existingFiles = await this.getExistingTaskFiles();\n      const existingIssueKeys = existingFiles.map(file => path.basename(file, '.md'));\n      \n      const removedIssueKeys = existingIssueKeys.filter(\n        key => !currentIssueKeys.includes(key)\n      );\n      \n      for (const issueKey of removedIssueKeys) {\n        await this.removeTaskFile(issueKey);\n      }\n      \n    } catch (error) {\n      console.error('Failed to cleanup removed issues:', error);\n    }\n  }\n\n  /**\n   * Read and parse a task file to extract title and description\n   */\n  async readTaskFile(issueKey: string): Promise<{ title: string; description: string } | null> {\n    try {\n      const taskFilePath = await this.findExistingTaskFile(issueKey);\n      if (!taskFilePath) {\n        return null;\n      }\n\n      const content = await fs.readFile(taskFilePath, 'utf8');\n      \n      const lines = content.split('\\n');\n      \n      // Extract title (first line starting with #)\n      const titleLine = lines.find(line => line.startsWith('# '));\n      const title = titleLine ? titleLine.replace('# ', '').trim() : '';\n      \n      // Extract description (everything after the title line)\n      const titleIndex = lines.findIndex(line => line.startsWith('# '));\n      let description = '';\n      \n      if (titleIndex !== -1) {\n        // Get everything after the title line\n        const descriptionLines = lines.slice(titleIndex + 1);\n        description = descriptionLines.join('\\n').trim();\n      }\n\n      return { title, description };\n    } catch (error) {\n      console.error(`Failed to read task file for ${issueKey}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Find all parent task folders (folders with pattern PARENT-{number})\n   */\n  async findParentTaskFolders(): Promise<string[]> {\n    try {\n      const parentFolders: string[] = [];\n      const entries = await fs.readdir(this.tasksDir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        if (entry.isDirectory()) {\n          // Check if folder name matches parent task pattern (e.g., SBK-2)\n          const parentPattern = /^[A-Z]+-\\d+$/;\n          if (parentPattern.test(entry.name)) {\n            parentFolders.push(entry.name);\n          }\n        }\n      }\n      \n      return parentFolders;\n    } catch (error) {\n      console.error('Failed to find parent task folders:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Find temporary task files in a parent folder (files with pattern PARENT-{number}-{random})\n   */\n  async findTemporaryTaskFiles(parentFolder: string): Promise<{ fileName: string; filePath: string; content: { title: string; description: string } }[]> {\n    try {\n      const parentFolderPath = path.join(this.tasksDir, parentFolder);\n      const entries = await fs.readdir(parentFolderPath, { withFileTypes: true });\n      const tempFiles: { fileName: string; filePath: string; content: { title: string; description: string } }[] = [];\n      \n      for (const entry of entries) {\n        if (entry.isFile() && entry.name.endsWith('.md')) {\n          const fileName = entry.name.replace('.md', '');\n          // Check if file name matches temporary pattern (e.g., SBK-2-1, SBK-2-2)\n          const tempPattern = new RegExp(`^${parentFolder}-\\\\d+$`);\n          if (tempPattern.test(fileName)) {\n            const filePath = path.join(parentFolderPath, entry.name);\n            const content = await fs.readFile(filePath, 'utf8');\n            \n            // Extract title and description\n            const lines = content.split('\\n');\n            const titleLine = lines.find(line => line.startsWith('# '));\n            const title = titleLine ? titleLine.replace('# ', '').trim() : '';\n            \n            const titleIndex = lines.findIndex(line => line.startsWith('# '));\n            let description = '';\n            if (titleIndex !== -1) {\n              const descriptionLines = lines.slice(titleIndex + 1);\n              description = descriptionLines.join('\\n').trim();\n            }\n            \n            tempFiles.push({\n              fileName,\n              filePath,\n              content: { title, description }\n            });\n          }\n        }\n      }\n      \n      return tempFiles;\n    } catch (error) {\n      console.error(`Failed to find temporary task files in ${parentFolder}:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Rename a task file from temporary name to real issue key\n   */\n  async renameTaskFile(oldFilePath: string, newIssueKey: string): Promise<void> {\n    try {\n      const newFilePath = path.join(path.dirname(oldFilePath), `${newIssueKey}.md`);\n      await fs.rename(oldFilePath, newFilePath);\n    } catch (error) {\n      throw new Error(`Failed to rename task file from ${oldFilePath} to ${newIssueKey}: ${error}`);\n    }\n  }\n\n  /**\n   * Create a task file with the correct issue key and content\n   */\n  async createTaskFile(issueKey: string, parentFolder: string, title: string, description: string, baseUrl: string): Promise<void> {\n    try {\n      const parentFolderPath = path.join(this.tasksDir, parentFolder);\n      const filePath = path.join(parentFolderPath, `${issueKey}.md`);\n      \n      // Ensure parent folder exists\n      await ensureDir(parentFolderPath);\n      \n      // Generate markdown content\n      let content = `# ${title}\\n\\n`;\n      if (description && description.trim() !== '') {\n        content += description;\n      }\n      \n      await fs.writeFile(filePath, content, 'utf8');\n    } catch (error) {\n      throw new Error(`Failed to create task file for ${issueKey}: ${error}`);\n    }\n  }\n} ","import * as fs from 'fs-extra';\nimport * as path from 'path';\nimport { BacklogConfig } from '../types/backlog.js';\n\nexport interface Config extends BacklogConfig {\n  tasksDir: string;\n  ignoreIssueTypes?: string[];\n}\n\n/**\n * Load configuration from config.json file or environment variables\n */\nexport async function loadConfig(): Promise<Config> {\n  // Try to load from config.json first\n  const configPath = path.resolve('config.json');\n  \n  if (await fs.pathExists(configPath)) {\n    try {\n      const configData = await fs.readJson(configPath);\n      \n      return {\n        apiKey: configData.apiKey,\n        baseUrl: configData.baseUrl,\n        projectKey: configData.projectKey,\n        tasksDir: configData.tasksDir || '.tasks',\n        ignoreIssueTypes: configData.ignoreIssueTypes || []\n      };\n    } catch (error) {\n      console.warn('Failed to load config.json, falling back to environment variables');\n    }\n  }\n\n  // Fall back to environment variables\n  const apiKey = process.env.BACKLOG_API_KEY;\n  const baseUrl = process.env.BACKLOG_BASE_URL;\n  const projectKey = process.env.BACKLOG_PROJECT_KEY;\n  const tasksDir = process.env.BACKLOG_TASKS_DIR || process.env.TASKS_DIR || '.tasks';\n  const ignoreIssueTypes = process.env.BACKLOG_IGNORE_ISSUE_TYPES \n    ? process.env.BACKLOG_IGNORE_ISSUE_TYPES.split(',').map(t => t.trim()) \n    : [];\n\n  if (!apiKey || !baseUrl || !projectKey) {\n    throw new Error(\n      'Missing required configuration. Please provide either:\\n' +\n      '1. A config.json file with apiKey, baseUrl, and projectKey\\n' +\n      '2. Environment variables: BACKLOG_API_KEY, BACKLOG_BASE_URL, BACKLOG_PROJECT_KEY\\n' +\n      'Optional environment variables: BACKLOG_TASKS_DIR, BACKLOG_IGNORE_ISSUE_TYPES'\n    );\n  }\n  \n  return {\n    apiKey,\n    baseUrl,\n    projectKey,\n    tasksDir,\n    ignoreIssueTypes\n  };\n}\n\n/**\n * Validate configuration\n */\nexport function validateConfig(config: Config): void {\n  if (!config.apiKey) {\n    throw new Error('API key is required');\n  }\n  \n  if (!config.baseUrl) {\n    throw new Error('Base URL is required');\n  }\n  \n  if (!config.projectKey) {\n    throw new Error('Project key is required');\n  }\n  \n  // Validate base URL format\n  try {\n    new URL(config.baseUrl);\n  } catch (error) {\n    throw new Error('Invalid base URL format');\n  }\n  \n  // Validate base URL is Backlog domain\n  if (!config.baseUrl.includes('backlog')) {\n    console.warn('Base URL does not appear to be a Backlog domain');\n  }\n} ","#!/usr/bin/env node\n\nimport { BacklogMcpServer } from './server.js';\nimport { loadConfig } from './utils/config.js';\n\nasync function main() {\n  try {\n    const config = await loadConfig();\n    const server = new BacklogMcpServer(config);\n    await server.start();\n  } catch (error) {\n    console.error('Failed to start Backlog MCP server:', error);\n  }\n}\n\nmain().catch(console.error);"],"mappings":"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","names":["axios","config","fs","fs","path"]}